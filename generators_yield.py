def func(x, y):
    for i in range(1, x + 1):
        yield i ** y
for n in func(10, 2):
    print(n, end=' ')
print()
for n in func(10, 3):
    print(n, end=' ')
print(*func(10, 2))

def func(x, y):
    for i in range(1, x + 1):
        yield i ** y
i = func(9, 3)
print(i.__next__())
print(i.__next__())
print(i.__next__())
print(i.__next__())
print(i.__next__())
print(i.__next__())

def gen(l):
    for e in l:
        yield from range(1, e + 1)
x = [5, 10]
print(*gen(x))


# Функция-генератор gen2.
# Принимает число n и генерирует четные числа от 2 до 2*n.
def gen2(n):
    # Итерируемся в диапазоне от 1 до n (включительно).
    for e in range(1, n + 1):
        # "Отдаем" (yield) текущее число e, умноженное на 2.
        # Функция приостанавливает свое выполнение здесь и вернет значение.
        # При следующем запросе значения, выполнение возобновится с этого места.
        yield e * 2

# Функция-генератор gen.
# Принимает список l и для каждого элемента этого списка
# делегирует генерацию функции gen2.
def gen(l):
    # Итерируемся по каждому элементу 'e' в предоставленном списке 'l'.
    for e in l:
        # 'yield from' используется для делегирования части операций другому генератору.
        # В данном случае, для каждого 'e' из 'l', генератор 'gen'
        # будет "отдавать" все значения, которые генерирует 'gen2(e)'.
        yield from gen2(e)

# Создаем список x с двумя числами.
x = [5, 10]
# Вызываем генератор gen(x).
# Оператор '*' (распаковка) извлекает все значения, которые генерирует gen(x),
# и передает их как отдельные аргументы функции print.
# Сначала gen2(5) сгенерирует: 2, 4, 6, 8, 10.
# Затем gen2(10) сгенерирует: 2, 4, 6, 8, 10, 12, 14, 16, 18, 20.
# Все эти числа будут напечатаны через пробел.
print(*gen(x))
